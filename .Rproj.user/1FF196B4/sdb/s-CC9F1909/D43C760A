{
    "contents" : "#Christopher Barry, started on 10/02/2015 at University of Birmingham\n\n#master script for automating 1-D flux algorithms\n\n#this was adapted for LO_5 on 30/06/2015\n\n#User Specify----\n#specific to LO_5\nsite <- \"JWa\"\nsite.A <- c(JWa = 650, JWb = 808, JWc = 571, CPM = 20509)\n\n#split pathline files? set to T for first time of use then set to F to save time thereafter\nsplit <- F\nif(split){\n  detect.by.capture = T\n  ptl.name <- paste0(\"LO_5p_\", site, \".ptl\")\n}\nptl.pref <- paste0(site, \"_ptl\")\n\n#Row, Column and Layer for successful capture by receptor in question\n#WG2 in LO_b2_6a\nRr <- 148\nCr <- 78\nLr <- 1\n\n#particle numbers (express as sequence 1:n, or test a single particle), lengths of stress periods and number of stress periods\nnp <- 1:160; np <- np[!file.exists(paste0(\"ptl\", np, \"_LT_\", site, \".dat\"))]\nsp.l <- c(3652, rep(c(366, rep(365, 3)), 100)[1:74], 10000)\nsps <- length(sp.l)\n\n#directories\ngendir <- \"C:/Users/cjb309/Documents/Scripts/R/\" #for scripts\ndir <- \"C:/Users/cjb309/Documents/GroundwaterModelling/LO_5/pathlines/\" #for saving files\n  source(paste0(gendir, \"td.R\"))\n\n#transport parameters - use one of aL or DL and set the other to NA\nJ0 <- function(area, recharge, concentration){return(area*recharge*concentration)} #source term\nA <- site.A[site]\nC <- 1100\nRch.vec <- read.table(paste0(dir, \"sourceR.dat\"))[, 1]\nsp <- function(ptlno){return(if(ptlno <= 104){ceiling(ptlno/2) + 21}else{76})}\nRch <- function(sp){return(Rch.vec[if(sp <= sps){sp}else{sps}])}\naL <- 200 #longitudinal dispersion coefficient\nDL <- NA #longitudinal dispersivity (= aL*v)\nRf <- 1 #retardation factor (normally set to one because dealt with separately by modified porosity)\ndec <- log(2)/3650 #decay constant [1/T]\ndur <- 365.25/2\n\n#times to plot results, relative to particle release time and scaled by the travel time\n#aim is to better resolve arrival and early tailing, with a few points to capture the long-term tailing\n#a few points are automatically removed where instability is likely in the LT method\ntime.points <- function(tot.time, dur, method = \"direct\"){\n  tptmp <- sort(c(tot.time*seq(0.01, 2, length.out = 50),\n                  tot.time*seq(2.1, 6, length.out = 20),\n                  tot.time*seq(6.1, 12, length.out = 10),\n                  tot.time*seq(12.5, 30, length.out = 5)))\n  if(method == \"LT\"){\n    tptmp2 <- tptmp[1]\n    for(tPt in 2:length(tptmp)){ #this removes time points which are likely to be unstable\n      if(!(tptmp[tPt] >= dur & tptmp[tPt] < dur + tot.time/10)){tptmp2 <- c(tptmp2, tptmp[tPt])}\n    }\n    tptmp <- tptmp2\n  }\n  return(tptmp)\n}\n\n#absolute time points at which to evaluate total flux, and the time value for the start of the model\nt.0 <- td(1, 1, 1930)\nev.times <- sort(c(seq(td(1, 1, 1950), td(1, 1, 2010), length.out = 800), seq(td(1, 3, 2010), td(1, 1, 2030), length.out = 30)))\n\n#solution method (\"LT\" or \"direct\")\nMTD <- \"direct\"\n\n#Laplace Transform parameters\nif(MTD == \"LT\"){\n  precision <- 15L #number of terms used in LT inversion\n  disc <- F\n  if(disc){\n    break.times <- seq(td(1,1,1950), td(1,1,2000), by = 365.25/2)\n  }else{break.times <- NA}\n}\n\n#file name\nwrite.to.file <- F\nsum.from.file <- T #sum all fluxes at end\nif(write.to.file | sum.from.file){\n  info <- paste0(\"\", site) #any extra distinguishing info about this run to be appended to file name\n}\n\n#for conversion to concentration:\n#receptor abstraction by stress period (data frame of length sps, with two colums (sp and Q))\nQr <- read.table(paste0(dir, \"WG2_Q.dat\"), header = T)\n#this script expects positive Q for abstraction, so use multiplier -1 if directly importing from MODFLOW e.g.\nQ.mult <- -1\n\n#remove new variables after run (turn off for debugging)\nclear.up <- F\n#----\n\n#source scripts----\n#These scripts provide the required functions and should be put in genDir.  These scripts will source other scripts.\nif(MTD == \"LT\"){library(\"invLT\")}\nif(MTD == \"direct\"){source(paste0(gendir, \"dir.R\"))}\nsource(paste0(gendir, \"PTLheaders.R\"))\nsource(paste0(gendir, \"DFtools.R\"))\nsource(paste0(gendir, \"FileTools.R\"))\n\n#split----\n#if splitting, this section will\nif(split){\n  ptl.df <- read.table(file = paste0(dir, ptl.name), skip = 1)\n  if(detect.by.capture){PTL.split(ptl.df, dir, Cr, Rr, Lr, pref = ptl.pref)}else{PTL.split(ptl.df, dir, pref = ptl.pref)}\n  if(clear.up){rm(ptl.df, ptl.name)}\n}\n\n#functions----\n#a function that detects whether a particle is captured by the receptor by analysing the last entry in its chopped data frame\ncapture <- function(PTL.df, Rr, Cr, Lr){ #determines whether the particle was captured by the receptor in question\n  if(missing(Lr)){Lr <- PTL.df$L[length(PTL.df$L)]} #if not identifying receptor by layer number, ensure that layer is not an issue for matching\n  if(last(PTL.df$C) == Cr & last(PTL.df$R) == Rr & last(PTL.df$L) == Lr){return(T)}else{return(F)}\n}\n\n#a function that returns the stress period number at a particular time (if time is beyond the bounds of the model, the first or last stress period number is returned as appropriate) - takes in the vectors sp.l and sp.t as a global\n#note the function is for model time, not absolute - use t - t.0 if t is absolute time\nspst <- rep(0, sps)\nfor(sp in 2:sps){spst[sp] <- sum(sp.l[1:(sp - 1)])}\nsp.t <- function(t){\n  return(which.max(spst[spst <= t]))\n}\nif(clear.up){rm(sp)}\n\n#a function to generate automated file names for saved data files\nif(write.to.file | sum.from.file){\n  f.nam <- function(ptlno, method, info){\n    return(paste0(\"ptl\", ptlno, \"_\", method, if(!identical(info, \"\")){\"_\"}else{\"\"}, info, \".dat\"))\n  }\n}else{f.nam <- function(ptlno, method, info){\"\"}}\n\n#load particle traces into list: puts a dummy data frame to return false with capture when the particle trace doesn't exist\nptl.traces <- lapply(paste0(dir, ptl.pref, np, \".ptl\"), function(f){ifelse(file.exists(f), read.table(f, header = T), data.frame(C = -1L, R = -1L, L = -1L))})\n\n#determine capture or not for each trace - saved into a logical vector\ncapd <- sapply(ptl.traces, capture, Rr, Cr, Lr)\n\n#list arrival times\narrivs <- sapply(ptl.traces, function(df){last(df[, \"t\"])})\n\ncap.sp <- rep(F, sps)\nfor(n in np[capd]){\n  ptl <- PTL.restructure(ptl.traces[[paste0(\"ptl\", n)]]) #don't just use ptl.traces[[n]] in case np isn't a sequence starting at 1; PTL.restructure converts the .ptl file data into distance (scalar), time and velocity (s,t,v)\n  trns.vec <- c(if(is.function(J0)){J0(A, C, Rch(sp.t(ptl$t[1])))}else{J0}, aL, DL, Rf, dec, dur) #transport parameters are packaged into a vector for easy parsing\n  cap.sp[sp.t(last(ptl$t))] <- T #particles are arriving at the receptor during this stress period\n  t <- time.points((last(ptl$t) - ptl$t[1])/2, trns.vec[6], MTD)\n  if(MTD == \"LT\"){ #Laplace Transform\n    plot.Jl.t(tPts = t, t0 = ptl$t[1], tPts.rel = T, PTL.df = ptl, write.to.file = write.to.file, folder.path = paste0(ds(dir), \"datafiles/\"), filename = f.nam(n, MTD, info), ptl.n = n, trns.df = trns.vec, disc = disc, break.times = break.times, prec = precision, extreme.alert = T)\n  }else if(MTD == \"direct\"){ #direct\n    Jdir(tPts = t, t0 = ptl$t[1], ptl, trns.vec, folder.path = paste0(ds(dir), \"datafiles/\"), filename = f.nam(n, MTD, info), write.to.file = write.to.file)\n  }\n  if(clear.up){rm(ptl, t)}\n}\n\nif(sum.from.file){\n  #sum the contributions----\n  J.sum <- data.frame(t = ev.times, J = 0) #initialise\n  for(n in np[capd]){\n    #only takes in captured results (other files shouldn't exist, but may if leftover from a previous run with different conditions)\n    f <- paste0(ds(dir), \"datafiles/\", f.nam(n, MTD, info))\n    df <- read.table(f, skip = 1, header = F)\n    J.int <- approx(df[, 1] + t.0, df[, 2], ev.times, yleft = 0, yright = 0) #interpolates to ev.times; yleft and yright = 0 will put 0 for any of ev.times that are outside the time range of the data frame\n    J.sum$J <- J.sum$J + J.int$y\n  }\n  #J.sum is written to file in next stage (when concentration calculated)\n\n  #calculate concetration from flux----\n  #determine time ranges at which particles are being captured (assumes capture for the whole stress period if one particle is capture in that sp - an approximation that may cause problems in time and will require more effort to solve)\n  names(Qr) <- c(\"sp\", \"Q\")\n  Qr$Q <- Qr$Q*Q.mult #apply multiplier (typically 1 or -1)\n  C <- rep(0, length(J.sum[, 1]))\n  #cat(cap.sp); cat(\"\\n\")\n  for(tn in 1:length(J.sum[, 1])){\n    sp <- sp.t(J.sum[tn, 1] - t.0)\n    #if(cap.sp[sp] & !identical(Qr$Q[sp], 0)){C[tn] <- J.sum[tn, 2]/Qr$Q[sp]}\n    if(!identical(Qr$Q[sp], 0)){C[tn] <- J.sum[tn, 2]/Qr$Q[sp]}\n  }\n  J.sum <- cbind(J.sum, C)\n  if(write.to.file){write.table(J.sum, paste0(ds(dir), \"datafiles/\", f.nam(\"SUM\", MTD, info)), row.names = F)} #doesn't matter that \"SUM\" is not numeric\n  plot(J.sum[, 1:2], type = \"l\", xlab = \"time\", ylab = \"flux\")\n  plot(J.sum[, c(1, 3)], type = \"l\", xlab = \"time\", ylab = \"concentration\")\n  #cat(\"total contaminant abstracted (in units of mass):\", integrate(approxfun(J.sum[, 1:2]), min(ev.times), max(ev.times))$value, \"\\n\")\n}\n\n#Clear up----\nif(clear.up){\n  if(MTD == \"LT\"){\n    if(disc){rm(break.times)}\n    rm(disc, precision)\n  }\n  if(write.to.file){rm(info, f.nam)}\n  rm(split, Rr, Cr, Lr, dir, J0, np, sps, sp, spst, aL, DL, Rf, dec, dur, trns.vec, time.points, MTD, write.to.file, capture, f, J.sum, J.int, df, tn, Qr, cap.sp, ptl.traces, capd)\n}\n",
    "created" : 1440777243672.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1039342954",
    "id" : "D43C760A",
    "lastKnownWriteTime" : 1441097854,
    "path" : "~/GroundwaterModelling/LO_5/scripts/FluxMaster_LO_5.R",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 8,
    "source_on_save" : false,
    "type" : "r_source"
}